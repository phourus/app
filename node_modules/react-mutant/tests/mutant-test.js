"use strict";
jest.dontMock('../index.js');
var Mutant, model, props;
props = {key: "value", list: [1, 2, 3], obj: {nested: "hash", another: "property"}};


// multiple listeners
// strict mode
describe("#ctor", function () {
	Mutant = require('../index.js');

	beforeEach(function () {
		model = new Mutant(props);
	});

	it("should have all props passed in as first argument", function () {
		var keys = Object.keys(props);
		keys.push('mutant');
		expect(model.key).toEqual(props.key);
		expect(model.list).toEqual(props.list);
		expect(model.obj).toEqual(props.obj);
		expect(Object.keys(model)).toEqual(keys);
	});

	it("should have a mutant property", function () {
		expect(model.mutant).toBeDefined();
		expect(model.mutant.get).toBeDefined();
		expect(model.mutant.set).toBeDefined();
		expect(model.mutant.on).toBeDefined();
		expect(model.mutant.off).toBeDefined();
		expect(model.mutant.trigger).toBeDefined();
	});
});

describe("#get", function () {

	beforeEach(function () {
		model = new Mutant(props);
	});

	it("should return all props except mutant", function () {
		expect(model.mutant.get()).toEqual(props);
	});

	it("should return new values when updated", function () {
		model.mutant.set({key: "newvalue"});
		expect(model.mutant.get().key).toEqual("newvalue");
	});

	it("should return new props in standard mode", function () {
		model = new Mutant(props);
		model.mutant.set({newkey: "value"});
		expect(model.mutant.get().newkey).toEqual("value");
	});

	it("should not return new props in strict mode", function () {
		model = new Mutant(props, {strict: true});
		model.mutant.set({newkey: "value"});
		expect(model.mutant.newkey).toBeUndefined();
		expect(model.mutant.get().newkey).toBeUndefined();
	});
});

describe("#set", function () {

	beforeEach(function () {
		model = new Mutant(props);
	});

	it("should update existing props", function () {
		var updatedList = model.list;
		expect(model.key).toEqual(props.key);
		expect(model.list).toEqual(props.list);

		updatedList.push(4);
		model.mutant.set({key: "newvalue", list: updatedList});
		expect(model.key).toEqual("newvalue");
		expect(model.list).toEqual([1, 2, 3, 4]);
	});

	it("should create new props in standard mode", function () {
		var keys = Object.keys(props);
		keys.push('mutant');
		expect(Object.keys(model)).toEqual(keys);

		model.mutant.set({added: "addedprop"});
		expect(model.added).toBeDefined();
		expect(model.added).toEqual("addedprop");
		keys.push('added');
		expect(Object.keys(model)).toEqual(keys);
	});

	it("should not create new props in 'strict' mode", function () {
		var keys = Object.keys(props);
		model = new Mutant(props, {strict: true});
		keys.push('mutant');
		expect(Object.keys(model)).toEqual(keys);

		model.mutant.set({added: keys.added});
		expect(model.added).toBeUndefined();
		expect(Object.keys(model)).toEqual(keys);
		keys.push('added');
		expect(Object.keys(model)).not.toEqual(keys);
	});
});

describe("#history", function () {

	beforeEach(function () {
		model = new Mutant(props);
	});

	it("should return an empty array after initialization", function () {
		expect(model.mutant.history()).toEqual([]);
	});

	it("should return a list of changed properties only", function () {
		var update1 = {key: "newvalue"};
		var update2 = {key: "newvalue", list: [1, 2]};
		var update3 = {newprop: "value"};
		model.mutant.set({key: "value"});
		expect(model.mutant.history()).toEqual([]);
		model.mutant.set(update1);
		expect(model.mutant.history()).toEqual([[update1]]);
		model.mutant.set(update2);
		expect(model.mutant.history()).toEqual([[update1], [{list: [1, 2]}]]);
		model.mutant.set(update2);
		expect(model.mutant.history()).toEqual([[update1], [{list: [1, 2]}]]);
		model.mutant.set(update3);
		expect(model.mutant.history()).toEqual([[update1], [{list: [1, 2]}], [update3]]);
	});
});

describe("#on", function () {

	beforeEach(function () {
		model = new Mutant(props);
	});

	it("should have a default 'update' event", function () { 
		model.mutant.on("update", function (data) {
			expect(data).toEqual(model);
		});
		model.mutant.set({});
	});

	it("should support custom event listeners", function () {
		var params = {some: "data", more: "data"};
		var cb = jest.genMockFn();
		model.mutant.on("custom", cb);
		model.mutant.trigger("custom", params);
		expect(cb).toBeCalledWith(params);
	});

	xit("should support multiple listeners", function () {
		var params = {something: "that has data"};
		var cb = jest.genMockFn();
		model.mutant.on("custom", cb);
		model.mutant.on("custom", cb);
		model.mutant.trigger("custom", params);
		expect(cb).toBeCalledWith(params);
	});
});

describe("#off", function () {

	beforeEach(function () {
		model = new Mutant(props);
	});

	it("should remove listeners", function () {
		var input = {some: "data", more: "data"};
		var cb = jest.genMockFn();
		model.mutant.on("custom", cb);
		model.mutant.off("custom");
		model.mutant.trigger("custom", input);
		expect(cb).not.toBeCalled();
	});
});

describe("#trigger", function () {

	beforeEach(function () {
		model = new Mutant(props);
	});

	it("should return false when listener has not been defined", function () {
		var result = model.mutant.trigger("nonexistant", {});
		expect(result).toBe(false);
	});
});